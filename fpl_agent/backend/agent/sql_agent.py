from dotenv import load_dotenv
from dataclasses import dataclass
from typing import Optional, List
from datetime import datetime
from enum import Enum
from fpl_agent.backend.agent.llm_manager import Prompt, LLMManager
from fpl_agent.backend.db.database_manager import DatabaseManager

load_dotenv()


# TODO: Prompt == separate class
# TODO: response == separate class?


class MessageRole(Enum):
    """Role of the message sender"""

    USER = "user"
    ASSISTANT = "assistant"
    SYSTEM = "system"


class MessageType(Enum):
    """Type of the message sent"""

    TEXT = "text"
    SQL = "sql"
    ERROR = "error"
    RESULT = "result"


@dataclass
class Message:
    role: MessageRole
    content: str
    type: MessageType
    timestamp: datetime
    error: Optional[str] = None
    result: Optional[dict] = None


class ChatState:
    """Manages conversation state and history"""

    def __init__(self):
        self.messages = List[Message] = []
        self.max_retries = 3

    def add_message(
        self,
        role: MessageRole,
        content: str,
        msg_type: MessageType,
        error: Optional[str] = None,
        result: Optional[dict] = None,
    ) -> Message:
        message = Message(
            role=role,
            content=content,
            type=msg_type,
            timestamp=datetime.now(),
            error=error,
            result=result,
        )
        self.messages.append(message)
        return message

    def get_error_context(self) -> str:
        """Get recent error context for LLM"""
        error_messages = []

        for msg in reversed(self.messages[-3:]):
            if msg.type == MessageType.ERROR:
                error_messages.append(f"Previous error: {msg.error}")
        return "\n".join(error_messages)


class Agent:
    """Main orchestrator that coordinates between managers"""

    def __init__(self):
        self.llm_manager = LLMManager()
        self.prompt = Prompt()
        self.db_manager = DatabaseManager()
        self.state = ChatState()

    # TODO: in-progress
    # async def process_question(self, question: str) -> List[Message]:
    #     """Process user question through the complete pipeline"""

    #     # add user question to history
    #     self.state.add_message(
    #         role=MessageRole.USER,
    #         content=question,
    #         msg_type=MessageType.TEXT
    #     )

    #     retry_count = 0
    #     while retry_count < self.state.max_retries:
    #         try:
    #             # get error context if there is any
    #             context = self.state.get_error_context()

    #             # ask LLM to generate SQL
    #             sql_query = await self.llm_manager.generate_sql(question, context)

    @staticmethod
    def _clean_sql_response(sql_response):
        clean_response = sql_response.replace("```", "")
        if clean_response.startswith("sql"):
            clean_response = clean_response.replace("sql", "")
        return clean_response

    def get_gemini_response(self, question):
        response = self.model.generate_content([self.prompt.instructions[0], question])
        return self._clean_sql_response(response.text)

    # TODO: get nouns for categorical columns
    # TODO: validate and fix sql prompt

    # TODO: need to use a db user with only read-access
    def read_sql_query(self, sql):
        """Takes SQL query generated by LLM model and executes it"""
        # if not self._db_connection:
        #     self._db_connection = psycopg2.connect(
        #     database=self.config.db_name,
        #     user=self.config.db_user,
        #     password=self.config.db_password,
        #     host=self.config.db_host,
        #     port=self.config.db_port
        #     )

        # cur = self._db_connection.cursor()
        # cur.execute(sql)
        # rows = cur.fetchall()
        # self._db_connection.commit()
        # self._db_connection.close()

        result = self.db_manager.execute_query(sql)

        for row in result:
            print(row)
        return result


# TODO: execute query


# TODO: DataAnalyzer


# TODO: DataVisualizer

# https://www.youtube.com/watch?v=wFdFLWc-W4k&list=PLApYU-BSLjraRb2M1Lcw0qS9SmDXNGMh9&ab_channel=KrishNaik

if __name__ == "__main__":
    agent = Agent()

    request = "Please return the 5 best players of the current season."

    response = agent.get_gemini_response(
        question=request,
    )

    result = agent.read_sql_query(response)

    # print(result)
    # for row in result:
    #     print(row)
